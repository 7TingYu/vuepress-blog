---
title: js utils - threejs - 02 动画
date: 2022-04-20
tags:
 - threejs
categories:
 - js utils
---


## 渲染

```js
var renderer = new THREE.WebGLRenderer();
renderer.setSize(width, height);//设置渲染区域尺寸
renderer.setClearColor(0xb9d3ff, 1); //设置背景颜色
document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
//执行渲染操作   指定场景、相机作为参数
renderer.render(scene, camera);
```

在 [01 基础概念](./01.md) 中，每执行一次渲染器对象 `WebGLRenderer` 的渲染方法.render()，浏览器就会渲染出一帧图像并显示在Web页面上，这就是说你按照一定的周期不停地调用渲染方法.render()就可以不停地生成新的图像覆盖原来的图像。

当我需要周期性渲染的时候，我们可以考虑两种方式：

- setInterval("render()",20)
- requestAnimationFrame(render)


## 周期性渲染

### setInterval

```js
// 渲染函数
function render() {
    renderer.render(scene,camera);//执行渲染操作
    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度
}
//间隔20ms周期性调用函数fun,20ms也就是刷新频率是50FPS(1s/20ms)，每秒渲染50次
setInterval("render()",20);
```

通过 `setInterval` 可以实现动画的加载，但我们在这边需要把控好渲染频率。

由于人眼的辨别频率为 16.7ms / 次，单独的使用 20ms 是完全不够的，同时在执行其他任务的时候可能会造成 `setInterval` 函数卡顿，体验并不理想，所以我们会使用 es 专门处理动画的函数 `requestAnimationFrame()`

### requestAnimationFrame

```js
function render() {
        renderer.render(scene,camera);//执行渲染操作
        mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度
        requestAnimationFrame(render);//请求再次执行渲染函数render
    }
render();
```

## 均匀旋转


在实际执行程序的时候，可能`requestAnimationFrame(render)`请求的函数并不一定能按照理想的60FPS频率执行，两次执行渲染函数的时间间隔也不一定相同，如果执行旋转命令的rotateY的时间间隔不同，旋转运动就不均匀，为了解决这个问题需要记录两次执行绘制函数的时间间隔。

```js
let T0 = new Date();//上次时间
function render() {
        let T1 = new Date();//本次时间
        let t = T1-T0;//时间差
        T0 = T1;//把本次时间赋值给上次时间
        requestAnimationFrame(render);
        renderer.render(scene,camera);//执行渲染操作
        mesh.rotateY(0.001*t);//旋转角速度0.001弧度每毫秒
    }
render();
```


